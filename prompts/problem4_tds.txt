Test-Driven Specification (TDS) Prompting Strategy

Implement a function using a test-driven approach. Follow these three phases:

PHASE 1: WRITE COMPREHENSIVE TESTS

Function Specification:
def is_palindrome(string: str) -> bool:
    """ Test if given string is a palindrome """
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """ Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """

Your Task: Write test cases that thoroughly verify this function.

Requirements:
1. Write at least 6-8 test cases using assert statements
2. CRITICAL: Use the EXACT function name 'make_palindrome' in ALL assertions
3. Cover these scenarios:
   - The provided examples above
   - Edge cases (empty inputs, single elements, None values where applicable)
   - Boundary conditions (at limits, just before/after thresholds)
   - Normal cases with various inputs
   - Any special cases mentioned in the docstring

Format your tests as:
    assert make_palindrome(...) == expected_result

Examples from the spec:
   >>> make_palindrome('')
   >>> make_palindrome('cat')

Write your test cases now:

PHASE 2: IMPLEMENT TO PASS YOUR TESTS

Now implement the function to pass ALL the tests you just wrote.

Critical Requirements:
1. Function name MUST be exactly: make_palindrome
2. Must handle all edge cases from your tests
3. Consider algorithm efficiency and stability
4. For numerical problems: use stable algorithms (e.g., bisection for root-finding)
5. Include proper type hints if shown in the specification

Implementation Guidelines:
- Start simple, then optimize if needed
- Ensure your logic handles all test cases
- For numerical precision: aim for high accuracy (typically 1e-4 or better)
- Don't over-engineer - clarity and correctness first

Provide your implementation:

PHASE 3: VERIFICATION & REFINEMENT

Mental Trace-Through:
1. Go through EACH test case you wrote in Phase 1
2. Mentally execute your implementation with those inputs
3. Verify the output matches expected results
4. Check edge cases work correctly

Self-Check Questions:
- Does my function name exactly match 'make_palindrome'?
- Did I handle all edge cases in my tests?
- Are there any off-by-one errors?
- For loops/iterations: am I using correct ranges?
- For numerical operations: is precision sufficient?
- Does it work for all input orderings/variations?

If you find any issues during verification, provide the CORRECTED implementation.
Otherwise, confirm your implementation is correct.

FINAL OUTPUT

Provide your final, verified implementation below (code only, ready to run):
