IMPROVED Self-Debug Prompt for problem8

import math


def poly(xs: list, x: float):
    """
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """ xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """


CRITICAL REQUIREMENTS:
1. Your function MUST be named exactly: find_zero
2. Do not rename or create alternative implementations
3. Function signature must match exactly

IMPLEMENTATION GUIDELINES:
1. First, implement a working solution with the EXACT function name
2. Test it with the provided examples
3. Debug any issues you find
4. Optimize if needed, but NEVER change the function name

For numerical problems:
- Use stable algorithms (bisection for root-finding)
- Verify convergence criteria
- Test edge cases

Common pitfalls to avoid:
- Using creative function names like find_zero_improved or find_zero_v2
- Over-engineering the solution
- Using unstable numerical methods

Your final code must define: def find_zero(...)
